<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>addresses.tex</title>
  <style>
    html {
      line-height: 1.5;
      font-family: Georgia, serif;
      font-size: 20px;
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      word-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 1em;
      }
    }
    @media print {
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, 'Lucida Console', Consolas, monospace;
      font-size: 85%;
      margin: 0;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
  </style>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<h1 class="title">addresses.tex</h1>
</header>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#chapter:addresses">Monero Addresses</a>
<ul>
<li><a href="#sec:user-keys">User keys</a></li>
<li><a href="#sec:one-time-addresses">One-time addresses</a>
<ul>
<li><a href="#sec:multi_out_transactions">Multi-output transactions</a></li>
</ul></li>
<li><a href="#sec:subaddresses">Subaddresses</a>
<ul>
<li><a href="#sending-to-a-subaddress">Sending to a subaddress</a></li>
</ul></li>
<li><a href="#sec:integrated-addresses">Integrated addresses</a></li>
<li><a href="#sec:multisignature-addresses">Multisignature addresses</a></li>
</ul></li>
</ul>
</nav>
<h1 id="chapter:addresses">Monero Addresses</h1>
<p>The ownership of digital currency stored in a blockchain is controlled by so-called ‘addresses’. Addresses are sent money which only the address-holder can spend.<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a></p>
<p>More specifically, an address owns the ‘outputs’ from some transactions, which are like notes giving the address-holder spending rights to an ‘amount’ of money. Such a note might say “Address C now owns 5.3 XMR".</p>
<p>To spend an owned output, the address-holder references it as the input to a new transaction. This new transaction has outputs owned by other addresses (or by the sender’s address, if the sender wants). A transaction’s total input amount equals its total output amount, and once spent an owned output can’t be respent. Carol, who has Address C, could reference that old output in a new transaction (e.g. “In this transaction I’d like to spend that old output.") and add a note saying “Address B now owns 5.3 XMR".</p>
<p>An address’s balance is the sum of amounts contained in its unspent outputs.<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a></p>
<p>We discuss hiding the amount from observers in Chapter <a href="#chapter:pedersen-commitments" data-reference-type="ref" data-reference="chapter:pedersen-commitments">[chapter:pedersen-commitments]</a>, the structure of transactions in Chapter <a href="#chapter:transactions" data-reference-type="ref" data-reference="chapter:transactions">[chapter:transactions]</a> (which includes how to prove you are spending an owned and previously unspent output, without even revealing which output is being spent), and the money creation process and role of observers in Chapter <a href="#chapter:blockchain" data-reference-type="ref" data-reference="chapter:blockchain">[chapter:blockchain]</a>.</p>
<h2 id="sec:user-keys">User keys</h2>
<p>Unlike Bitcoin, Monero users have two sets of private/public keys, <span class="math inline">\((k^v, K^v)\)</span> and <span class="math inline">\((k^s, K^s)\)</span>, generated as described in Section <a href="#ec:keys" data-reference-type="ref" data-reference="ec:keys">[ec:keys]</a>.</p>
<p>The <span><em>address</em></span> of a user is the pair of public keys <span class="math inline">\((K^v, K^s)\)</span>. Her private keys will be the corresponding pair <span class="math inline">\((k^v, k^s)\)</span>.<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a><br />
Using two sets of keys allows function segregation. The rationale will become clear later in this chapter, but for the moment let us call private key <span class="math inline">\(k^v\)</span> the <span><em>view key</em></span>, and <span class="math inline">\(k^s\)</span> the <span><em>spend key</em></span>. A person can use their view key to determine if their address owns an output, and their spend key will allow them to spend that output in a transaction (and retroactively figure out it has been spent).<a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a></p>
<h2 id="sec:one-time-addresses">One-time addresses</h2>
<p>To receive money, a Monero user may distribute their address to other users, who can then send it money via transaction outputs.</p>
<p>The address is never used directly.<a href="#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a> Instead, a Diffie-Hellman-like exchange is applied to it, creating a unique <span><em>one-time address</em></span> for each transaction output to be paid to the user. In this way, even external observers who know all users’ addresses cannot use them to identify which user owns any given transaction output.<a href="#fn6" class="footnote-ref" id="fnref6" role="doc-noteref"><sup>6</sup></a></p>
<p>Let’s start with a very simple mock transaction, containing exactly one output — a payment of ‘0’ amount from Alice to Bob.</p>
<p>Bob has private/public keys <span class="math inline">\((k_B^v, k_B^s)\)</span> and <span class="math inline">\((K_B^v, K_B^s)\)</span>, and Alice knows his public keys (his address). The mock transaction could proceed as follows <span class="citation" data-cites="cryptoNoteWhitePaper"></span>:</p>
<ol>
<li><p>Alice generates a random number <span class="math inline">\(r \in_R \mathbb{Z}_l\)</span>, and calculates the one-time address<a href="#fn7" class="footnote-ref" id="fnref7" role="doc-noteref"><sup>7</sup></a> <span class="math display">\[K^o  = \mathcal{H}_n(r K_B^v)G + K_B^s\marginnote{src/crypto/ crypto.cpp {\tt derive\_pu- blic\_key()}}\]</span></p></li>
<li><p>Alice sets <span class="math inline">\(K^o\)</span> as the addressee of the payment, adds the output amount ‘0’ and the value <span class="math inline">\(r G\)</span> to the transaction data, and submits it to the network.</p></li>
<li><p>Bob receives the data and sees the values <span class="math inline">\(r G\)</span> and <span class="math inline">\(K^o\)</span>. He can calculate <span class="math inline">\(k_B^v r G = r K_B^v\)</span>. He can then calculate <span class="math inline">\(K&#39;^s_B = K^o - \mathcal{H}_n(r K_B^v)G\)</span>. When he sees that <span class="math inline">\(K&#39;^s_B = K_B^s\)</span>, he knows the output is addressed to him.<a href="#fn8" class="footnote-ref" id="fnref8" role="doc-noteref"><sup>8</sup></a></p>
<p>The private key <span class="math inline">\(k_B^v\)</span> is called the ‘view key’ because anyone who has it (and Bob’s public spend key <span class="math inline">\(K_B^s\)</span>) can calculate <span class="math inline">\(K&#39;^s_B\)</span> for every transaction output in the blockchain (record of transactions), and ‘view’ which ones belong to Bob.</p></li>
<li><p>The one-time keys for the output are: <span class="math display">\[\begin{aligned}
        K^o &amp;= \mathcal{H}_n(r K_B^v)G + K_B^s = (\mathcal{H}_n(r K_B^v) + k_B^s)G  \\ 
        k^o &amp;= \mathcal{H}_n(r K_B^v) + k_B^s
    \end{aligned}\]</span></p></li>
</ol>
<p>To spend his ‘0’ amount output [sic] in a new transaction, all Bob needs to do is prove ownership by signing a message with the one-time key <span class="math inline">\(K^o\)</span>. The private key <span class="math inline">\(k_B^s\)</span> is the ‘spend key’ since it is required for proving output ownership, while <span class="math inline">\(k_B^v\)</span> is the ‘view key’ since it can be used to find outputs spendable by Bob.</p>
<p>As will become clear in Chapter <a href="#chapter:transactions" data-reference-type="ref" data-reference="chapter:transactions">[chapter:transactions]</a>, without <span class="math inline">\(k^o\)</span> Alice can’t compute the output’s key image, so she can never know for sure if Bob spends the output she sent him.<a href="#fn9" class="footnote-ref" id="fnref9" role="doc-noteref"><sup>9</sup></a></p>
<p>Bob may give a third party his view key. Such a third party could be a trusted custodian, an auditor, a tax authority, etc. Somebody who could be allowed read access to the user’s transaction history, without any further rights. This third party would also be able to decrypt the output’s amount (to be explained in Section <a href="#sec:pedersen_monero" data-reference-type="ref" data-reference="sec:pedersen_monero">[sec:pedersen_monero]</a>). See Chapter <a href="#chapter:tx-knowledge-proofs" data-reference-type="ref" data-reference="chapter:tx-knowledge-proofs">[chapter:tx-knowledge-proofs]</a> for other ways Bob could provide information about his transaction history.</p>
<h3 id="sec:multi_out_transactions">Multi-output transactions</h3>
<p>Most transactions will contain more than one output. If nothing else, to transfer ‘change’ back to the sender.<a href="#fn10" class="footnote-ref" id="fnref10" role="doc-noteref"><sup>10</sup></a><a href="#fn11" class="footnote-ref" id="fnref11" role="doc-noteref"><sup>11</sup></a></p>
<p>Monero senders usually generate only one random value <span class="math inline">\(r\)</span>. The curve point <span class="math inline">\(r G\)</span> is typically known as the <span><em>transaction public key</em></span> and is published alongside other transaction data in the blockchain.<br />
To[-.8cm] ensure that all one-time addresses in a transaction with <span class="math inline">\(p\)</span> outputs are different even in cases where the same addressee is used twice, Monero uses an output index. Every output from a transaction has an index <span class="math inline">\(t \in \{0, ..., p-1\}\)</span>. By appending this value to the shared secret before hashing it, one can ensure the resulting one-time addresses are unique:[1.2cm] <span class="math display">\[\begin{aligned}
  K_t^o &amp;= \mathcal{H}_n(r K_t^v, t)G + K_t^s = (\mathcal{H}_n(r K_t^v, t) + k_t^s)G  \\ 
  k_t^o &amp;= \mathcal{H}_n(r K_t^v, t) + k_t^s\end{aligned}\]</span></p>
<h2 id="sec:subaddresses">Subaddresses</h2>
<p>Monero users can generate subaddresses from each address <span class="citation" data-cites="MRL-0006-subaddresses"></span>. Funds sent to a subaddress can be viewed and spent using its main address’s view and spend keys. By analogy: an online bank account may have multiple balances corresponding to credit cards and deposits, yet they are all accessible and spendable from the same point of view – the account holder.<br />
Subaddresses are convenient for receiving funds to the same place when a user doesn’t want to link his activities together by publishing/using the same address. As we will see, most observers would have to solve the DLP to determine a given subaddress is derived from any particular address <span class="citation" data-cites="MRL-0006-subaddresses"></span>.<a href="#fn12" class="footnote-ref" id="fnref12" role="doc-noteref"><sup>12</sup></a></p>
<p>They are also useful for differentiating between received outputs. For example, if Alice wants to buy an apple from Bob on a Tuesday, Bob could write a receipt describing the purchase and make a subaddress for that receipt, then ask Alice to use that subaddress when she sends him the money. This way Bob can associate the money he receives with the apple he sold. We explore another way to distinguish between received outputs in the next section.</p>
<p>Bob generates his <span class="math inline">\(i^\nth\)</span> subaddress <span class="math inline">\((i = 1, 2, ...)\)</span> from his address as a pair of public keys <span class="math inline">\((K^{v,i}, K^{s,i})\)</span>:<a href="#fn13" class="footnote-ref" id="fnref13" role="doc-noteref"><sup>13</sup></a> <span class="math display">\[\begin{aligned}
    K^{s,i} &amp;= K^s + \mathcal{H}_n(k^v, i) G\\
    K^{v,i} &amp;= k^v K^{s,i}\end{aligned}\]</span> So, <span class="math display">\[\begin{aligned}
{2}
    K^{v,i} &amp;= k^v&amp;&amp;(k^s + \mathcal{H}_n(k^v, i))G\\
    K^{s,i} &amp;= &amp;&amp;(k^s + \mathcal{H}_n(k^v, i))G\end{aligned}\]</span></p>
<h3 id="sending-to-a-subaddress">Sending to a subaddress</h3>
<p>Let’s say Alice is going to send Bob ‘0’ amount again, this time via his subaddress <span class="math inline">\((K_B^{v,1}, K_B^{s,1})\)</span>.</p>
<ol>
<li><p>Alice generates a random number <span class="math inline">\(r \in_R \mathbb{Z}_l\)</span>, and calculates the one-time address <span class="math display">\[K^o  = \mathcal{H}_n(r K_B^{v,1},0)G + K_B^{s,1}\]</span></p></li>
<li><p>Alice sets <span class="math inline">\(K^o\)</span> as the addressee of the payment, adds the output amount ‘0’ and the value <span class="math inline">\(r K_B^{s,1}\)</span> to the transaction data, and submits it to the network.</p></li>
<li><p>Bob receives the data and sees the values <span class="math inline">\(r K_B^{s,1}\)</span> and <span class="math inline">\(K^o\)</span>. He can calculate <span class="math inline">\(k_B^v r K_B^{s,1} = r K_B^{v,1}\)</span>. He can then calculate <span class="math inline">\(K&#39;^{s}_B = K^o - \mathcal{H}_n(r K_B^{v,1},0)G\)</span>. When he sees that <span class="math inline">\(K&#39;^{s}_B = K^{s,1}_B\)</span>, he knows the transaction is addressed to him.<a href="#fn14" class="footnote-ref" id="fnref14" role="doc-noteref"><sup>14</sup></a></p>
<p>Bob only needs his private view key <span class="math inline">\(k_B^v\)</span> and subaddress public spend key <span class="math inline">\(K^{s,1}_B\)</span> to find transaction outputs sent to his subaddress.</p></li>
<li><p>The one-time keys for the output are: <span class="math display">\[\begin{aligned}
        K^o &amp;= \mathcal{H}_n(r K_B^{v,1},0)G + K_B^{s,1} = (\mathcal{H}_n(r K_B^{v,1},0) + k_B^{s,1})G  \\ 
        k^o &amp;= \mathcal{H}_n(r K_B^{v,1},0) + k_B^{s,1}
    \end{aligned}\]</span></p></li>
</ol>
<p>Now, Alice’s transaction public key is particular to Bob (<span class="math inline">\(r K_B^{s,1}\)</span> instead of <span class="math inline">\(r G\)</span>). If she creates a <span class="math inline">\(p\)</span>-output transaction with at least one output intended for a subaddress, Alice needs to make a unique transaction public key for each output <span class="math inline">\(t \in \{0,...,p-1\}\)</span>. In other words, if Alice is sending to Bob’s subaddress <span class="math inline">\((K_B^{v,1}, K_B^{s,1})\)</span> and Carol’s address <span class="math inline">\((K_C^v, K_C^s)\)</span>, she will put two transaction public keys {<span class="math inline">\(r_1 K_B^{s,1},r_2 G\)</span>} in the transaction data.<a href="#fn15" class="footnote-ref" id="fnref15" role="doc-noteref"><sup>15</sup></a><a href="#fn16" class="footnote-ref" id="fnref16" role="doc-noteref"><sup>16</sup></a></p>
<h2 id="sec:integrated-addresses">Integrated addresses</h2>
<p>To differentiate between the outputs they receive, a recipient can request senders include a <span><em>payment ID</em></span> in transaction data.<a href="#fn17" class="footnote-ref" id="fnref17" role="doc-noteref"><sup>17</sup></a> For example, if Alice wants to buy an apple from Bob on a Tuesday, Bob could write a receipt describing the purchase and ask Alice to include the receipt’s ID number when she sends him the money. This way Bob can associate the money he receives with the apple he sold.</p>
<p>At one point senders could communicate payment IDs in clear text, but manually including the IDs in transactions is inconvenient, and cleartext is a privacy hazard for recipients, who might inadvertently expose their activities.<a href="#fn18" class="footnote-ref" id="fnref18" role="doc-noteref"><sup>18</sup></a> In Monero, recipients can integrate payment IDs into their addresses, and provide those <span><em>integrated addresses</em></span>, containing (<span class="math inline">\(K^v\)</span>, <span class="math inline">\(K^s\)</span>, payment ID), to senders. Payment IDs can technically be integrated into any kind of address, including normal addresses, subaddresses, and multisignature addresses.<a href="#fn19" class="footnote-ref" id="fnref19" role="doc-noteref"><sup>19</sup></a></p>
<p>Senders addressing outputs to integrated addresses can encode payment IDs using the shared secret <span class="math inline">\(r K_t^v\)</span> and an XOR operation (recall Section <a href="#sec:XOR_section" data-reference-type="ref" data-reference="sec:XOR_section">[sec:XOR_section]</a>), which recipients can then decode with the appropriate transaction public key and another XOR operation <span class="citation" data-cites="integrated-addresses"></span>. Encoding payment IDs in this way also allows senders to prove they made particular transaction outputs (e.g. for audits, refunds, etc.).<a href="#fn20" class="footnote-ref" id="fnref20" role="doc-noteref"><sup>20</sup></a></p>
<h4 class="unnumbered" id="encoding">Encoding</h4>
<p>The sender encodes the payment ID for inclusion in transaction data<a href="#fn21" class="footnote-ref" id="fnref21" role="doc-noteref"><sup>21</sup></a> <span class="math display">\[\begin{aligned}
         k_{\textrm{mask}} &amp;= \mathcal{H}_n(r K_t^v,\textrm{pid\_tag}) \\
      k_{\textrm{payment ID}} &amp;= k_{\textrm{mask}} \rightarrow \textrm{reduced to bit length of payment ID}\\
  \textrm{encoded payment ID} &amp;= \textrm{XOR}(k_{\textrm{payment ID}}, \textrm{payment ID})\end{aligned}\]</span></p>
<p>We include pid_tag to ensure <span class="math inline">\(k_{\textrm{mask}}\)</span> is different from the component <span class="math inline">\(\mathcal{H}_n(r K_t^v, t)\)</span> in one-time output addresses.<a href="#fn22" class="footnote-ref" id="fnref22" role="doc-noteref"><sup>22</sup></a></p>
<h4 class="unnumbered" id="decoding">Decoding</h4>
<p>Whichever recipient the payment ID was created for can find it using his view key and the transaction public key <span class="math inline">\(r G\)</span>:<a href="#fn23" class="footnote-ref" id="fnref23" role="doc-noteref"><sup>23</sup></a> <span class="math display">\[\begin{aligned}
         k_{\textrm{mask}} &amp;= \mathcal{H}_n(k_t^v r G,\textrm{pid\_tag}) \\
      k_{\textrm{payment ID}} &amp;= k_{\textrm{mask}} \rightarrow \textrm{reduced to bit length of payment ID}\\
          \textrm{payment ID} &amp;= \textrm{XOR}(k_{\textrm{payment ID}}, \textrm{encoded payment ID})\end{aligned}\]</span></p>
<p>Similarly, senders can decode payment IDs they had previously encoded by recalculating the shared secret.</p>
<h2 id="sec:multisignature-addresses">Multisignature addresses</h2>
<p>Sometimes it is useful to share ownership of funds between different people/addresses. We dedicate Chapter <a href="#chapter:multisignatures" data-reference-type="ref" data-reference="chapter:multisignatures">[chapter:multisignatures]</a> to elaborating this topic.</p>
<section class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p>Except with negligible probability.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2" role="doc-endnote"><p>Computer applications known as ‘wallets’ are used to find and organize the outputs owned by an address, to maintain custody of its private keys for authoring new transactions, and to submit those transactions to the network for verification and inclusion in the blockchain.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3" role="doc-endnote"><p>To communicate an address to other users, it is extremely common to encode it in base-58, a binary-to-text encoding scheme first created for Bitcoin <span class="citation" data-cites="base-58-encoding"></span>. See <span class="citation" data-cites="luigi-address"></span> for more details.<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4" role="doc-endnote"><p>It is currently most common for the view key <span class="math inline">\(k^v\)</span> to equal <span class="math inline">\(\mathcal{H}_n(k^s)\)</span>. This means a person only needs to save their spend key <span class="math inline">\(k^s\)</span> in order to access (view and spend) all of the outputs they own (spent and unspent). The spend key is typically represented as a series of 25 words (where the 25th word is a checksum). Other, less popular methods include: generating <span class="math inline">\(k^v\)</span> and <span class="math inline">\(k^s\)</span> as separate random numbers, or generating a random 12-word mnemonic <span class="math inline">\(a\)</span>, where <span class="math inline">\(k^s = {\tt sc\textunderscore reduce32}(\mathit{Keccak}(a))\)</span> and <span class="math inline">\(k^v = {\tt sc\textunderscore reduce32}(\mathit{Keccak}(\mathit{Keccak}(a)))\)</span>. <span class="citation" data-cites="luigi-address"></span><a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn5" role="doc-endnote"><p>The method described here is not enforced by the protocol, just by wallet implementation standards. This means an alternate wallet could follow the style of Bitcoin where recipients’ addresses are included directly in transaction data. Such a non-compliant wallet would produce transaction outputs unusable by other wallets, and each Bitcoin-esque address could only be used once due to key image uniqueness.<a href="#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn6" role="doc-endnote"><p>Except with negligible probability.<a href="#fnref6" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn7" role="doc-endnote"><p>In Monero, every instance (including when it’s used for other parts of the transaction) of <span class="math inline">\(r k^v G\)</span> is multiplied by the cofactor 8, so in this case Alice computes <span class="math inline">\(8*r K^v_B\)</span> and Bob computes <span class="math inline">\(8*k^v_B r G\)</span>. As far as we can tell this serves no purpose (but it <span><em>is</em></span> a rule that users must follow). Multiplying by the cofactor ensures the resulting point is in <span class="math inline">\(G\)</span>’s subgroup, but if <span class="math inline">\(R\)</span> and <span class="math inline">\(K^v\)</span> don’t share a subgroup to begin with, then the discrete logs <span class="math inline">\(r\)</span> and <span class="math inline">\(k^v\)</span> can’t be used to make a shared secret regardless.<a href="#fnref7" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn8" role="doc-endnote"><p><span class="math inline">\(K&#39;^s_B\)</span> is computed with <span><code>derive_subaddress_public_key()</code></span> because normal address spend keys are stored at index 0 in the spend key lookup table, while subaddresses are at indices 1,2... This will make sense soon: see Section <a href="#sec:subaddresses" data-reference-type="ref" data-reference="sec:subaddresses">1.3</a>.<a href="#fnref8" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn9" role="doc-endnote"><p>Imagine Alice produces two transactions, each containing the same one-time output address <span class="math inline">\(K^o\)</span> that Bob can spend. Since <span class="math inline">\(K^o\)</span> only depends on <span class="math inline">\(r\)</span> and <span class="math inline">\(K_B^v\)</span>, there is no reason she can’t do it. Bob can only spend one of those outputs because each one-time address only has one key image, so if he isn’t careful Alice might trick him. She could make transaction 1 with a lot of money for Bob, and later transaction 2 with a small amount for Bob. If he spends the money in 2, he can never spend the money in 1. In fact, no one could spend the money in 1, effectively ‘burning’ it. Monero wallets have been designed to ignore the smaller amount in this scenario.<a href="#fnref9" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn10" role="doc-endnote"><p>Actually, as of protocol v12 two outputs are <span><em>required</em></span> from each (non-miner) transaction, even if it means one output has 0 amount (<span><code>HF_VERSION_MIN_2_OUTPUTS</code></span>). This improves transaction indistinguishability by mixing 1-output cases with the much more common 2-output transactions. Previous to v12 the core wallet software was already creating 0-value outputs. The core implementation sends 0-amount outputs to a random address.<a href="#fnref10" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn11" role="doc-endnote"><p>After Bulletproofs were implemented in protocol v8, each transaction became limited to no more than 16 outputs (<span><code>BULLETPROOF_MAX_OUTPUTS</code></span>). Previously there was no limit, aside from a restraint on transaction size (in bytes).<a href="#fnref11" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn12" role="doc-endnote"><p>Prior to subaddresses (added in the software update corresponding with protocol v7 <span class="citation" data-cites="subaddress-pull-request"></span>), Monero users could simply generate many normal addresses. To view each address’s balance, you needed to do a separate scan of the blockchain record. This was very inefficient. With subaddresses, users maintain a look-up table of (hashed) spend keys, so one scan of the blockchain takes the same amount of time for 1 subaddress, or 10,000 subaddresses.<a href="#fnref12" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn13" role="doc-endnote"><p>It turns out the subaddress hash is domain separated, so it’s really <span class="math inline">\(\mathcal{H}_n(T_{sub},k^v,i)\)</span> where <span class="math inline">\(T_{sub} =\)</span>“SubAddr". We omit <span class="math inline">\(T_{sub}\)</span> throughout this document for brevity.<a href="#fnref13" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn14" role="doc-endnote"><p>An advanced attacker may be able to link subaddresses <span class="citation" data-cites="janus-attack"></span> (a.k.a. the Janus attack). With subaddresses (one of which can be a normal address) <span class="math inline">\(K_B^1\)</span> <span class="math inline">\(\&amp;\)</span> <span class="math inline">\(K_B^2\)</span> the attacker thinks may be related, he makes a transaction output with <span class="math inline">\(K^o = \mathcal{H}_n(r K_B^{v,2},0)G + K_B^{s,1}\)</span> and includes transaction public key <span class="math inline">\(r K_B^{s,2}\)</span>. Bob calculates <span class="math inline">\(r K_B^{v,2}\)</span> to find <span class="math inline">\(K&#39;^{s,1}_B\)</span> but has no way of knowing it was his <span><em>other</em></span> (sub)address’s key used! If he tells the attacker that he received funds to <span class="math inline">\(K_B^1\)</span>, the attacker will know <span class="math inline">\(K_B^2\)</span> is a related subaddress (or normal address). Since subaddresses are outside the protocol’s scope, mitigations are up to wallet implementers. No known wallets have done so, and any mitigation would only work for compliant wallets. Potential mitigations include: not informing attackers of received funds, including encrypted transaction private key <span class="math inline">\(r\)</span> in transaction data, a Schnorr signature on the shared secret using <span class="math inline">\(K^{s,1}\)</span> as the base point instead of <span class="math inline">\(G\)</span>, and including <span class="math inline">\(rG\)</span> in transaction data and verifying the shared secret with <span class="math inline">\(rK^{s,1} \stackrel{?}{=} (k^s + \mathcal{H}_n(k^v, 1))*rG\)</span> (requires the private spend key). Outputs received by a normal address should also be verified. See <span class="citation" data-cites="janus-mitigation-issue-62"></span> for a discussion of the last mitigation listed.<a href="#fnref14" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn15" role="doc-endnote"><p>In Monero subaddresses are prefixed with an ‘8’, separating them from addresses, which are prefixed with ‘4’. This helps senders choose the correct procedure when constructing transactions.<a href="#fnref15" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn16" role="doc-endnote"><p>There is some intricacy to when additional transaction public keys are used (see the code path <span><code>transfer_selected_rct()</code></span> <span class="math inline">\(\rightarrow\)</span> <span><code>construct_tx_and_get_tx_key()</code></span> <span class="math inline">\(\rightarrow\)</span> <span><code>construct_tx_with_tx_key()</code></span> <span class="math inline">\(\rightarrow\)</span> <span><code>generate_output_ephemeral_keys()</code></span> and <span><code>classify_addresses()</code></span>) surrounding change outputs where the transaction author knows the recipient’s view key (since it’s himself; also the case for dummy change outputs, which are created when a 0-amount output is necessary, since authors generate those addresses). Whenever there are at least two non-change outputs, and at least one of their recipients is a subaddress, proceed in the normal way explained above (a current bug in the core implementation adds an extra transaction public key to transaction data even beyond the additional keys, which is not used for anything). If either just the change output is to a subaddress, or there is just one non-change output and it’s to a subaddress, then only one transaction public key is created. In the former case, the transaction public key is <span class="math inline">\(rG\)</span> and the change’s one-time key is (subaddress index 1, using <span class="math inline">\(c\)</span> subscript to denote the change’s keys) <span class="math inline">\(K^o = \mathcal{H}_n(k^v_c r G,t)G + K_c^{s,1}\)</span> using the normal view key and subaddress’s spend key. In the latter case the transaction public key <span class="math inline">\(r K^{v,1}\)</span> is based off the subaddress’s view key, and the change’s one time key is <span class="math inline">\(K^o = \mathcal{H}_n(k^v_c*r K^{v,1},t)G + K_c^s\)</span>. These details help mingle a portion of subaddress transactions amongst the more common normal address transactions, and 2-output transactions which compose around 95% of transaction volume as of this writing.<a href="#fnref16" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn17" role="doc-endnote"><p>Currently, Monero implementations only support one payment ID per transaction regardless of how many outputs it has.<a href="#fnref17" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn18" role="doc-endnote"><p>These long-form (256 bit) cleartext payment IDs were deprecated in v0.15 of the core software implementation (coincident with protocol v12 in November 2019). While other wallets may still support them and allow their inclusion in transaction data, the core wallet will ignore them.<a href="#fnref18" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn19" role="doc-endnote"><p>Within the authors’ knowledge, integrated addresses have only ever been implemented for normal addresses.<a href="#fnref19" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn20" role="doc-endnote"><p>Since an observer can recognize the difference between transactions with and without payment IDs, using them is thought to make the Monero transaction history less uniform. Because of this, since protocol v10 the core implementation adds a dummy encrypted payment ID to all 2-output transactions. Decoding one will reveal all 0s (this is not required by the protocol, just best practice).<a href="#fnref20" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn21" role="doc-endnote"><p>In Monero payment IDs for integrated addresses are conventionally 64 bits long.<a href="#fnref21" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn22" role="doc-endnote"><p>In Monero, pid_tag = <span><code>ENCRYPTED_PAYMENT_ID_TAIL</code></span> = 141. In, for example, multi-input transactions we compute <span class="math inline">\(\mathcal{H}_n(r K_t^v, t) \pmod l\)</span> to ensure we are using a scalar less than the EC subgroup order, but since <span class="math inline">\(l\)</span> is 253 bits and payment IDs are only 64 bits, taking the modulus for encoding payment IDs would be meaningless, so we don’t.<a href="#fnref22" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn23" role="doc-endnote"><p>Transaction data does not indicate which output a payment ID ‘belongs’ to. Recipients have to identify their own payment IDs.<a href="#fnref23" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
</body>
</html>
